---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.13.0
  kernelspec:
    display_name: bioinf
    language: python
    name: bioinf
---

```{python}
# %autosave 0
```

```{python}
import os
import pandas as pd

res_path = '/home/gabi/diplomka/results/'
base_names = ['labeled_train', 'labeled_valid_unseen_networks-val_loss',
              'labeled_valid_unseen_images-val_loss',
             'labeled_valid_unseen_images-test_loss',
             'labeled_valid_unseen_images_nets-test_loss']

def process_res_directory(dir_path: str, with_baselines=True):
    loss_df = pd.read_csv(os.path.join(dir_path, 'loss.csv'), index_col=0)    
    metrics_df = pd.read_csv(os.path.join(dir_path, 'metrics.csv'), index_col=0)
                            
    res_df = pd.concat([loss_df, metrics_df], axis=1)
    res_df.reset_index(inplace=True)
    
    exp_name = dir_path.split('/')[-3]
    res_df.insert(0, 'exp_name', exp_name)
    
    if with_baselines:
        baselines = {}
        base_files = ['train_long_baseline.csv', 'valid_long_baseline.csv',
                      'test_small_split_baseline.csv', 'test_train_long_baseline.csv',
                     'test_valid_long_baseline.csv']
        for name, baseline in zip(base_names, base_files):
            baseline_path = os.path.join(dir_path, baseline)
            base_df = pd.read_csv(baseline_path, index_col=0)

            baselines[name] = base_df

        return exp_name, res_df, baselines
    
    return exp_name, res_df
```

```{python}
import glob

dfs = []
baseline_dict = {}
in_dirs = glob.glob(os.path.join(res_path, 'with*/*/'))

for dir_p in in_dirs:
    name, res = process_res_directory(dir_p, with_baselines=False)
    
    dfs.append(res)
    
dfs = pd.concat(dfs)
_, _, base = process_res_directory(in_dirs[0])
```

```{python}
base
```

```{python}
dfs.columns
```

```{python}
shadow_columns = [
    'labeled_labeled',
    'labeled_valid_unseen_networks-val_loss',
    'labeled_valid_unseen_images-val_loss',
    # TODO test set
]
```

```{python}
base_keys = list(base.keys())
base_keys
```

```{python}
base['labeled_train']
```

```{python}
(dfs['labeled_valid_unseen_networks-L1'] == dfs['labeled_valid_unseen_networks-val_loss']).all()
```

```{python}
import numpy as np

train_samples = 608000
val_samples = 77000
test_samples = 122000
test_train_samples = 1094000
test_val_samples = 154000

sample_list = [train_samples, val_samples, test_samples, test_train_samples, test_val_samples]

def ci_95(std, sample_size):
    return 1.96 * std / np.sqrt(sample_size)
```

```{python}
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib notebook
sns.set()

titles = ['Train loss', 'Validation loss (unseen networks)',
         'Validation loss (unseen images)',
         'Test loss (unseen images)',
         'Test loss (unseen images and networks)']

use_stats = '_median'
use_stats = ''

save_path = '/home/gabi/diplomka/neurips/paper/diplomka_to_neurips/img/info-losses/'
# save_path = '/home/gabi/diplomka/master-thesis/img/info-losses/'
if not os.path.exists(save_path):
    os.mkdir(save_path)

for run_column, ref_columns, sample_s, title in zip(shadow_columns, base_keys, sample_list, titles):
    plt.figure(figsize=(7,5))
    stats_title = ''
    
    for stats in [run_column, run_column + '_median']:
    
        if stats not in dfs.columns:
            continue

        run_data = dfs[['exp_name', 'index', stats]]
        print(run_data.columns)

        ref = base[ref_columns].iloc[1]

        if 'median' in stats:
            ref_title = "median"
            ref_val = ref['median']
            col = 'orange'
            
            stats_title += f', median ref: {ref["median"].round(2)}'
            label = f"Median, reference: {ref['median'].round(2)}"
        else:            
            ref_title = "mean"
            col = "r"
            
            stats_title += f'mean ref: {ref["mean"].round(2)}'
            ref_val = ref['mean']
            ref_ci = ci_95(ref['std'], sample_s)
            ci_title = f"${ref_val} \pm {ref_ci}$"
            
            label = f"Mean, reference: {ref['mean'].round(2)} $\pm$ {ref_ci.round(4)}"
            
            #if ref_ci.round(3) > 0:
            #    stats_title += f" $\pm$ {ref_ci.round(3)}"
            #else:
            stats_title += f" $\pm$ {ref_ci.round(4)}"
            print(ref_ci)
            
            # plt.fill_between(np.arange(30) + 1, ref_val - ref_ci, ref_val + ref_ci, alpha=0.3, color=col)
            
        # plt.hlines(ref_val,1,30, label=f"Reference {ref_title}", colors=col)

        ax = sns.lineplot(data=run_data, x='index', y=stats, label=label)
        plt.setp(ax.get_legend().get_texts(), fontsize='13')
    #plt.hlines(ref_mean, 1, 30, colors='r')
    #plt.fill_between(np.arange(1, 31), ref_mean + ref_ci, ref_mean - ref_ci)
    
    #plt.title(f"{title}, {stats_title}", fontsize=13.8)
    plt.title(title, fontsize=17)
    
    if 'networks' in title:
        low, up = plt.ylim()
        plt.ylim(low, up + 0.06)
    
    plt.xlabel('Epoch', fontsize=13)
    plt.ylabel(f'Loss', fontsize=13)
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, f"{run_column}.png"), dpi=500)
    plt.show()
```

```{python}
# Tohleto už stačí, test set budou boxploty, teď to samý pro recon acc a train loss 
```

```{python}

```

```{python}
dfs.columns
```

```{python}
stats_list = ['unlabeled', 'acc_ops_val', 'acc_adj_val', 'validity', 'uniqueness']
titles = ['VAE loss', 'Operation reconstruction accuracy', 'Adjacency reconstruction accuracy',
         'Validity', 'Uniqueness']
# %matplotlib notebook

save_path = '/home/gabi/diplomka/master-thesis/img/info-arch-comparison/'
if not os.path.exists(save_path):
    os.mkdir(save_path)


for title, column in zip(titles, stats_list):
    plt.figure(figsize=(7,5))

    label_name = f"labeled_{column}" if column not in ['validity', 'uniqueness'] else f"unlabeled_{column}"
    ref_name = f"reference_{column}"
    
    run_data = dfs[['exp_name', 'index', label_name, ref_name, 'unlabeled_unlabeled']]
    print(run_data.columns)

    info_nas_label = 'Info-NAS' if column != 'unlabeled' else 'Info-NAS unlabeled batches'
    arch2vec_label = 'arch2vec' if column != 'unlabeled' else 'arch2vec all batches'
    sns.lineplot(data=run_data, x='index', y=label_name, label=info_nas_label)
    sns.lineplot(data=run_data, x='index', y=ref_name, label=arch2vec_label)
    
    if column == 'unlabeled':
        sns.lineplot(data=run_data, x='index', y='unlabeled_unlabeled', label='Info-NAS unlabeled batches')
    #plt.hlines(ref_mean, 1, 30, colors='r')
    #plt.fill_between(np.arange(1, 31), ref_mean + ref_ci, ref_mean - ref_ci)
    
    plt.title(f"{title}", fontsize=14)
    plt.xlabel('Epoch', fontsize=12)
    plt.ylabel(f'Mean value', fontsize=12)
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, f"{column}.png"), dpi=500)
    plt.show()
```

```{python}

```

```{python}

```
