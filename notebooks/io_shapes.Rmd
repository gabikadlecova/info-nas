---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.13.0
      jupytext_formats: ipynb,Rmd:rmarkdown
  kernelspec:
    display_name: bioinf
    language: python
    name: bioinf
---

```{python}
# %autosave 0
```

```{python}
from info_nas.datasets.networks.pretrained import pretrain_network_cifar
from info_nas.datasets.networks.utils import load_nasbench
from nasbench_pytorch.datasets.cifar10 import prepare_dataset
```

```{python}
seed = 42
batch_size = 32
num_workers = 2

dataset = prepare_dataset(batch_size, root='../data/cifar/', validation_size=1000, random_state=seed,
                          num_workers=num_workers)
train, n_train, val, n_val, test, n_test = dataset
```

```{python}
import os

checkpoint_dir = '../data/train_checkpoints//'

os.listdir(f'{checkpoint_dir}')
```

```{python}
from nasbench import api

nasbench_path = '../data/nasbench_only108.tfrecord'
nb = api.NASBench(nasbench_path)
```

```{python}
import torch
from info_nas.datasets.networks.utils import load_trained_net

device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')

net_path = f'{checkpoint_dir}083a8045a46ac2a25a34c8fab47f6ecb.tar'
net_hash, net, info = load_trained_net(net_path, nb, device=device)
net
```

```{python}
info
```

```{python}
net.classifier.bias
```

- heatmaps todo
  - all net weights for e.g. airplane
  - minmaxscale to (-1,1), compare net
    - bias?
  - standardscale instead of normalize
  - predict one image, sort values by weights
    - how to normalize??

```{python}
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib notebook

labels = "airplane, automobile, bird, cat, deer, dog, frog, horse, ship, truck".split(', ')

weights = net.classifier.weight.detach().cpu()

plt.figure(figsize=(5,6))
sns.heatmap(weights, yticklabels=labels)
#plt.imshow(net.classifier.weight.detach().cpu())
plt.tight_layout()
plt.savefig('cifar_weights.png')
plt.show()
```

```{python}
import numpy as np

print(net_hash)
np.array([net_hash, net_hash, net_hash])
```

```{python}
type(net_hash)
```

```{python}
for batch_idx, (inputs, targets) in enumerate(val):
    inputs, targets = inputs.to(device), targets.to(device)
    break
    
print(inputs.shape)
print(targets.shape)
```

```{python}
nasbench = load_nasbench(nasbench_path)
```

```{python}
from nasbench_pytorch.model import Network as NBNetwork

net = nasbench[0]
net = NBNetwork((net[2], net[1]), 10)
net = net.to(device)
```

```{python}
with torch.no_grad():
    outputs = net(inputs.to(device))
    
outputs.shape
```

```{python}
with torch.no_grad():
    out_list = net.get_cell_outputs(inputs, return_inputs=False)
    
[print(o.shape) for o in out_list]
print()
```

```{python}
with torch.no_grad():
    in_list, out_list = net.get_cell_outputs(inputs, return_inputs=True)
    
[print(i.shape, ' -> ', o.shape) for i, o in zip(in_list, out_list)]
print()
```

```{python}
torch.cat(in_list[:2]).shape
```

```{python}
with torch.no_grad():
    in_list, out_list = net.get_cell_outputs(inputs, return_inputs=True)
    
for in_image in in_list[-2][0][:10]:
    print(in_image.shape)
```

```{python}
means = np.array([0.4914, 0.4822, 0.4465])[:, np.newaxis, np.newaxis]
stds = np.array([0.2023, 0.1994, 0.2010])[:, np.newaxis, np.newaxis]
im = inputs[1].detach().cpu() * stds + means
```

```{python}
targets[1]
```

```{python}
plt.figure(figsize=(1,1))
plt.imshow(im.moveaxis(0,2))
plt.show()
```

```{python}
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib notebook

for in_image in in_list[-2][1][:10]:
    plt.figure(figsize=(1,1))
    plt.imshow(in_image.detach().cpu())
    plt.show()

```

```{python}
# Check if all shapes the same
```

```{python}
for i, next_net in enumerate(nasbench[:150]):
    if (i % 5) == 0:
        print(i)

    next_net = NBNetwork((next_net[2], next_net[1]), 10)
    
    with torch.no_grad():        
        n_in, n_out = next_net.get_cell_outputs(inputs, return_inputs=True)
        
        for i, ni in zip(in_list, n_in):
            assert i.shape == ni.shape
            
        for o, no in zip(out_list, n_out):
            assert o.shape == no.shape
```

```{python}
len(nasbench)
```

```{python}

```
